# JAVA基础
8.11
编译java文件
javac Hello.java
运行class
java Hello

.java文件(源文件) 经过编译之后  会出来.class 文件(字节码文件)

有了.java源文件，可以通过编译器将其编译成JVM可以识别的字节码文件。
在该文件目录下，通过javac编译工具对.java文件进行编译。

\n  换行符
\\ 一个\
\"







数据类型
--数据类型包括 8个基本数据，3个引用类型
基本类型

数值型   
1.整数  byte[1] short[2] int[4] long[8]
2.浮点 float[4]  double[8]

3. 字符型  char[2]
4. 布尔型 boolean[1]

引用数据类型

1.类   class
2.接口 interface
3.数组  []


标记 byte范围 -128 ~ 127



#### JavaScript 类型运算符

| 运算符     | 描述                                  |
| :--------- | :------------------------------------ |
| typeof     | 返回变量的类型。                      |
| instanceof | 返回 true，如果对象是对象类型的实例。 |





byte 等于1个字节，一个 byte 等于 8 个 bit 。  bit  计算机中最小的存储单元
short  等于2个字节
单精度 float  4字节    范围 -3.404E38 ~ 3.404E38
双精度 double 8字节 范围-1.898E308 ~ 1.898E308
浮点数  =  符号位 + 指数位 + 尾数位
尾数部分可能丢失 ， 造成精度损失（小数都是近似值）

java的浮点型常量默认为double 型，声明float型常量，需后加F 或f

浮点类型常量两种表达形式
十进制：5.12   512.0f   .512(可以省略0 但是必须有小数点)
科学计数法  5.12e2  [5.12*10的2次方]    5.12E-2  [5.12/10的2次方]

关于计算好之后的 浮点数进行比较 应该使用 Math.abs(小数-小数) < 0.000001
利用两个数的 差值来判断是否相等  （计算之后的数因该是科学计数法）

```java
double num1 = 2.7 
double num2 = 8.1/3  //2.7
if(num1 == num2){ //不相等}
//正确写法 
if(Math.abs(num1 - num2) < 0.0000001){
    System.out.println("差值非常小，达到我规定的精度。认为相等");
}
```


## JAVA API

中文在线 matools.com


字符常量 是用单引号
char的本质是整数  输出的时候是  Unicode的之后的
```java
char c1 = 97;
System.out.println(c1);//a
char c2 = 'a';//输出a对应的数字 
System.out.println((int)c2);//强转

//char类型是可以进行运算的，相当于一个整数 因为它都对应有Unicode码
System.out.println('a' + 10);//107

//输出对应的字符 ->编码表ASCII
```


字符型 存储到计算机中， 需要将字符对应的码值（整数） 找出来，比如a
储存 ： ' a ' ==> 码值 97 ==> 二进制 ==> 存储
读取： 二进制 =>97 ==> ' a ' => 显示

背会
当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换
数据类型按照精度大小排序为（背，规则）
低精度向高精度转换
char  -  int - long - float - double
byte - short - int - long - float - double
```java
int num = 'a';  // char - > int 
double d1 = 80;  // int - > double
```
byte short 和 char 不会自动互相转换
byte short  char 计算时会首先转换为int类型

```java
//即使  
byte b1 =1;
byte b2 =2;
byte num =  b1+b2;//也会报错
```
boolean 不参与类型的自动转换
自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型

### 强制类型转换
>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符（） ，但是可能造成精度降低过或者溢出，格外注意。



### String 对应的基本类型
```java
//parse 引文单词:解析
//使用基本类型对应的包装类的相应方法，得到基本数据类型。
String s = "12";
int num1 = Integer.parseInt(s);
Double d = Double.parseDouble(s);
  

```


作为表达式使用
前++ ：++i 先自增后赋值
后++ ： i++ 先复制后自增

int j = 8;  //
int k = j++; //K=8,j=9

前++和后++都完全等价于i=i+1
前++    ++i 先自增后赋值
后++  i++ 先赋值后自增

逻辑运算符



### &&短路与和&逻辑与区别
&&第一个条件为false 后面的条件不再执行
&第一个条件为false 后面的条件仍然会执行

### !  和  ^

```java
//!取反  
(60 > 20) //true
!(60 > 20) //false
//^ 逻辑异或
//a ^ b 当a和b不同时，则结果为true ，否则为false
boolean  b = ( 10 > 1 ) ^ ( 3 < 5 )//false

```
### +=
a+=b;  等价于  a = a + b;


赋值运算符会有类型转换



### 三元运算符
条件表达式 ？ 表达式1：表达式2；
运算规则 ：
1.如果条件表达式为true ，运算后的结果是表达式1
2.如果条件表达式为false，运算后的结果是表达式2
a>b ? a++ :b--



### 运算符优先级

### 二进制的转换
二进制转10进制
规则：从最低位（右边）开始，将每个位上的数提取出来 乘以2的（位数-1）次方 然后求和。
次方 ： 3的5次方 等于5个3相乘
10011 = 1*2的（1-1）次方+1*2的（2-1）次方+0*2的（3-1）次方+1*2的（4-1）次方 = 1+2+0+8=11

八进制转10进制
规则：从最低位（右边）开始，将每个位上的数提取出来 乘以8的（位数-1）次方 然后求和。


16进制转10进制
规则：从最低位（右边）开始，将每个位上的数提取出来 乘以16的（位数-1）次方 然后求和。

### 十进制转二进制
规则  将该数不断除以2，知道商为0为止，然后将每步得到的余数倒过来就是对应的二进制。


### 十进制转八进制
规则  将该数不断除以8，知道商为0为止，然后将每步得到的余数倒过来就是对应的二进制。


### 十进制转八进制
规则  将该数不断除以16，知道商为0为止，然后将每步得到的余数倒过来就是对应的二进制。

### 二进制转八进制
从低位开始，将二进制数每三位一组，转成对应的八进制数即可。




### 原码 反码 补码


1.二进制的最高位：0表示正数，1表示负数
2.正数的原码、反码、补码都一样（三码合一）
3.负数的反码 = 它的原码符号位不变，其他位取反（0->1,1->0）
4.负数的补码=它的反码+1，负数的反码 = 负数的补码 - 1
5.0的反码，补码都是0
6.java没有无符号数，换言之，java中的数都是有符号的
7.计算机在运算的时候  都是以补码的方式在运算
8.当我们看运算结果  要看他的原码






### 位运算符
>>  <<  >>>
1.  算术右移 >> ：低位溢出，符号位不变，并用符号位补溢出的高位
2. 算术左边移  <<  : 符号位不变，低位补0
3. >>>逻辑右移也叫无符号右移，算术规则是：低位溢出，高位补0
4. 特别说明 ：没有<<<符号、


### for
int i=1；
for( ; i <= 10; ){
.......
i++

}













### 英文记录
assign 分配、委派、指定、布置
Ternary operator 三元运算符



















